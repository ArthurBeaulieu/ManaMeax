/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/css/meax.scss":
/*!***************************!*\
  !*** ./src/css/meax.scss ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "./src/js/Meax.js":
/*!************************!*\
  !*** ./src/js/Meax.js ***!
  \************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _core_UserInterface_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core/UserInterface.js */ "./src/js/core/UserInterface.js");
/* harmony import */ var _core_DeviceHandler_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./core/DeviceHandler.js */ "./src/js/core/DeviceHandler.js");
/* harmony import */ var _core_PlaybackController_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./core/PlaybackController.js */ "./src/js/core/PlaybackController.js");
/* harmony import */ var _utils_Enums_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/Enums.js */ "./src/js/utils/Enums.js");
/* harmony import */ var _utils_Utils_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils/Utils.js */ "./src/js/utils/Utils.js");
/* harmony import */ var _utils_CustomEvents_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./utils/CustomEvents.js */ "./src/js/utils/CustomEvents.js");









window.CustomEvents = new _utils_CustomEvents_js__WEBPACK_IMPORTED_MODULE_5__["default"]();
window.Utils = new _utils_Utils_js__WEBPACK_IMPORTED_MODULE_4__["default"]();
window.Enums = _utils_Enums_js__WEBPACK_IMPORTED_MODULE_3__["default"];

class Meax {


  constructor() {
    this._dh = null;
    this._pc = null;
    this._ui = null;
  }


  init() {
    this._dh = new _core_DeviceHandler_js__WEBPACK_IMPORTED_MODULE_1__["default"]({
      onEvent: this._onControllerEvent.bind(this)
    });

    this._pc = new _core_PlaybackController_js__WEBPACK_IMPORTED_MODULE_2__["default"]();
    this._ui = new _core_UserInterface_js__WEBPACK_IMPORTED_MODULE_0__["default"]();
  }


  _onControllerEvent(element) {
    console.log(element);
    // First bit is component ID
    const componentId = element.id.charAt(0);
    // Remove ID bit to get command unique ID
    const actionId = element.id.slice(1);
    // Analyse event origin and type to call proper method
    if (componentId === _utils_Enums_js__WEBPACK_IMPORTED_MODULE_3__["default"].Components.MIXER) {
      this._mixerEvents(element, actionId);
    } else if (componentId === _utils_Enums_js__WEBPACK_IMPORTED_MODULE_3__["default"].Components.DECK_LEFT) {
      this._deckEvents('left', element, actionId);
    } else if (componentId === _utils_Enums_js__WEBPACK_IMPORTED_MODULE_3__["default"].Components.DECK_RIGHT) {
      this._deckEvents('right', element, actionId);
    } else if (componentId === _utils_Enums_js__WEBPACK_IMPORTED_MODULE_3__["default"].Components.PAD_LEFT) {
      this._padEvents('left', element, actionId, false);
    } else if (componentId === _utils_Enums_js__WEBPACK_IMPORTED_MODULE_3__["default"].Components.PAD_LEFT_SHIFT) {
      this._padEvents('left', element, actionId, true);
    } else if (componentId === _utils_Enums_js__WEBPACK_IMPORTED_MODULE_3__["default"].Components.PAD_RIGHT) {
      this._padEvents('right', element, actionId, false);
    } else if (componentId === _utils_Enums_js__WEBPACK_IMPORTED_MODULE_3__["default"].Components.PAD_RIGHT_SHIFT) {
      this._padEvents('right', element, actionId, true);
    }
  }


  _mixerEvents(element, actionId) {
    if (actionId === _utils_Enums_js__WEBPACK_IMPORTED_MODULE_3__["default"].Commands.LEFT_LOAD_TRACK && element.value === 'push') {
      // Add track on left deck update model in pc then update UI with track info (duration, bpm etc)
      this._pc.addTrack('left', this._ui.getSelectedTrack())
        .then(track => { this._ui.addTrack('left', track); });
    } else if (actionId === _utils_Enums_js__WEBPACK_IMPORTED_MODULE_3__["default"].Commands.RIGHT_LOAD_TRACK && element.value === 'push') {
      // Add track on right deck update model in pc then update UI with track info (duration, bpm etc)
      this._pc.addTrack('right', this._ui.getSelectedTrack())
        .then(track => { this._ui.addTrack('right', track); });
    } else if (actionId === _utils_Enums_js__WEBPACK_IMPORTED_MODULE_3__["default"].Commands.SELECTION_ROTARY) {
      // Navigate on pl is a UI only action
      this._ui.navigateInPlaylist('left', element.value);
    } else if (actionId === _utils_Enums_js__WEBPACK_IMPORTED_MODULE_3__["default"].Commands.LEFT_FILTER) {
      // Left filter knob first applies HPF or HPF on channel output, then update the UI knob
      this._pc.setFilter('left', element.value).then(options => { this._ui.setFilter('left', options); });
    } else if (actionId === _utils_Enums_js__WEBPACK_IMPORTED_MODULE_3__["default"].Commands.RIGHT_FILTER) {
      // Right filter knob first applies HPF or HPF on channel output, then update the UI knob
      this._pc.setFilter('right', element.value).then(options => { this._ui.setFilter('right', options); });
    } else if (actionId === _utils_Enums_js__WEBPACK_IMPORTED_MODULE_3__["default"].Commands.CROSSFADER) {
      this._pc.crossFade(element.value);
    }
  }


  _deckEvents(side, element, actionId) {
    if (actionId === _utils_Enums_js__WEBPACK_IMPORTED_MODULE_3__["default"].Commands.PLAY && element.value === 'push') {
      const playStatus = this._pc.togglePlayback(side, element);
      this._dh.sendMIDIMessage([element.raw[0], element.raw[1], playStatus]);
    } else if (actionId === _utils_Enums_js__WEBPACK_IMPORTED_MODULE_3__["default"].Commands.CUE_PHONES_LEFT && element.value === 'push') {
      this._pc.setCuePhone(side, element);
    } else if (actionId === _utils_Enums_js__WEBPACK_IMPORTED_MODULE_3__["default"].Commands.PERFORMANCE_TAB_1) {
      this._pc.setPadType(side, element, 0);
    } else if (actionId === _utils_Enums_js__WEBPACK_IMPORTED_MODULE_3__["default"].Commands.PERFORMANCE_TAB_2) {
      this._pc.setPadType(side, element, 1);
    } else if (actionId === _utils_Enums_js__WEBPACK_IMPORTED_MODULE_3__["default"].Commands.PERFORMANCE_TAB_3) {
      this._pc.setPadType(side, element, 2);
    } else if (actionId === _utils_Enums_js__WEBPACK_IMPORTED_MODULE_3__["default"].Commands.PERFORMANCE_TAB_4) {
      this._pc.setPadType(side, element, 3);
    } else if (actionId === _utils_Enums_js__WEBPACK_IMPORTED_MODULE_3__["default"].Commands.PERFORMANCE_TAB_5) {
      this._pc.setPadType(side, element, 4);
    } else if (actionId === _utils_Enums_js__WEBPACK_IMPORTED_MODULE_3__["default"].Commands.PERFORMANCE_TAB_6) {
      this._pc.setPadType(side, element, 5);
    } else if (actionId === _utils_Enums_js__WEBPACK_IMPORTED_MODULE_3__["default"].Commands.PERFORMANCE_TAB_7) {
      this._pc.setPadType(side, element, 6);
    } else if (actionId === _utils_Enums_js__WEBPACK_IMPORTED_MODULE_3__["default"].Commands.PERFORMANCE_TAB_8) {
      this._pc.setPadType(side, element, 7);
    } else if (actionId === _utils_Enums_js__WEBPACK_IMPORTED_MODULE_3__["default"].Commands.VOLUME) {
      this._pc.setVolume(side, element.value);
    } else if (actionId === _utils_Enums_js__WEBPACK_IMPORTED_MODULE_3__["default"].Commands.VOLUME_TRIM) {
      this._pc.setTrimVolume(side, element.value);
    } else if (actionId === _utils_Enums_js__WEBPACK_IMPORTED_MODULE_3__["default"].Commands.TEMPO) {
      this._pc.setTempo(side, element.value);
    } else if (actionId === _utils_Enums_js__WEBPACK_IMPORTED_MODULE_3__["default"].Commands.JOGWHEEL_SLOW) {
      this._pc.adjustProgressSlow(side, element.value);
    } else if (actionId === _utils_Enums_js__WEBPACK_IMPORTED_MODULE_3__["default"].Commands.JOGWHEEL_FAST) {
      this._pc.adjustProgressFast(side, element.value);
    } else if (actionId === _utils_Enums_js__WEBPACK_IMPORTED_MODULE_3__["default"].Commands.HIGH_EQ) {
      this._pc.setHighEQ(side, element.value);
    } else if (actionId === _utils_Enums_js__WEBPACK_IMPORTED_MODULE_3__["default"].Commands.MID_EQ) {
      this._pc.setMidEQ(side, element.value);
    } else if (actionId === _utils_Enums_js__WEBPACK_IMPORTED_MODULE_3__["default"].Commands.LOW_EQ) {
      this._pc.setLowEQ(side, element.value);
    }
  }


  _padEvents(side, element, actionId, shift) {
    if (actionId === _utils_Enums_js__WEBPACK_IMPORTED_MODULE_3__["default"].Commands.PAD_1) {
      this._pc.setPad(side, element, 1, shift);
    } else if (actionId === _utils_Enums_js__WEBPACK_IMPORTED_MODULE_3__["default"].Commands.PAD_2) {
      this._pc.setPad(side, element, 2, shift);
    } else if (actionId === _utils_Enums_js__WEBPACK_IMPORTED_MODULE_3__["default"].Commands.PAD_3) {
      this._pc.setPad(side, element, 3, shift);
    } else if (actionId === _utils_Enums_js__WEBPACK_IMPORTED_MODULE_3__["default"].Commands.PAD_4) {
      this._pc.setPad(side, element, 4, shift);
    } else if (actionId === _utils_Enums_js__WEBPACK_IMPORTED_MODULE_3__["default"].Commands.PAD_5) {
      this._pc.setPad(side, element, 5, shift);
    } else if (actionId === _utils_Enums_js__WEBPACK_IMPORTED_MODULE_3__["default"].Commands.PAD_6) {
      this._pc.setPad(side, element, 6, shift);
    } else if (actionId === _utils_Enums_js__WEBPACK_IMPORTED_MODULE_3__["default"].Commands.PAD_7) {
      this._pc.setPad(side, element, 7, shift);
    } else if (actionId === _utils_Enums_js__WEBPACK_IMPORTED_MODULE_3__["default"].Commands.PAD_8) {
      this._pc.setPad(side, element, 8, shift);
    }

    this._dh.sendMIDIMessage(element.raw);
  }


  get pc() {
    return this._pc;
  }

  get dh() {
    return this._dh;
  }


}


window.Meax = new Meax();
/* harmony default export */ __webpack_exports__["default"] = (Meax);


/***/ }),

/***/ "./src/js/core/DeviceHandler.js":
/*!**************************************!*\
  !*** ./src/js/core/DeviceHandler.js ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _utils_Enums_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/Enums.js */ "./src/js/utils/Enums.js");



class DeviceHandler {


  constructor(options) {
    this._onEvent = options.onEvent;
    this._channels = [];

    this._input = null;
    this._output = null;
    this._knobLow = null;

    if (navigator.requestMIDIAccess) {
      navigator.requestMIDIAccess().then(this.requestMIDIAccess.bind(this), this.requestMIDIAccessFailure);
    } else {
      console.log('navigator.requestMIDIAccess undefined on this browser. Try on Chromium/Chrome.');
    }

    this._setEventSubscriptions();
  }


  _setEventSubscriptions() {
    CustomEvents.subscribe(`Player/CuePhones`, this._cuePhones.bind(this));
  }


  requestMIDIAccess(midi) {
    var inputs = midi.inputs.values();
    var outputs = midi.outputs.values();

    for (var input = inputs.next(); input && !input.done; input = inputs.next()) {
      if (input.value.name === 'DDJ-400') {
        this._input = input;
        this._readJSONFile(`./assets/json/${input.value.name}.json`).then(response => {
          this._channels = response.channels;
          input.value.onmidimessage = this.midiOnMIDImessage.bind(this);
          input.value.onstatechange = this.midiOnStateChange;
        });
        break;
      } else {
        console.log(`Unsupported device ${input.value.name}, contact support@manazeak.org to support this device.`);
      }
    }

    for (var output = outputs.next(); output && !output.done; output = outputs.next()) {
      if (output.value.name === 'DDJ-400') {
        this._output = output;
      } else {
        console.log(`Unsupported device ${output.value.name}, contact support@manazeak.org to support this device.`);
      }
    }
  }


  sendMIDIMessage(options) {
    this._output.value.send(options);
  }


  midiOnMIDImessage(event) {
    const args = this._parseMIDIArguments(event.data);
    // Send MIDI input arguments to retrieve the mapped element
    const element = this._retrieveElementFromDeviceMapping(args);
    // Only send calback if element exists in device mapping
    if (element) {
      element.args = args; // If element exists, we add its arguments
      element.raw = event.data; // Use on MIDI out to notify controller of state change
      const evt = this._buildMIDIEvent(element);
      if (evt) {
        this._onEvent(evt);
      }
    }
  }


  _parseMIDIArguments(data) {
    return {
      type: event.data[0] & 0xf0,
      cmd: event.data[0] >> 4,
      channel: event.data[0] & 0xf,
      note: event.data[1],
      velocity: event.data[2], //  / 127 to get percenatge
    }
  }


  _retrieveElementFromDeviceMapping(args) {
    // Output object, default to null (not found)
    let output = null;
    // Parse devices channels defined in JSON file associated with controller
    for (let i = 0; i < this._channels.length; ++i) {
      // Parse current channel subchannels (several channel can map a same set of keys)
      for (let j = 0; j < this._channels[i].channel.length; ++j) {
        // In case we match the channel value in sub channels, proceed to retrieve element from channel definition
        if (args.channel === this._channels[i].channel[j].value) {
          const element = this._findMatchingElementInChannel(args, this._channels[i]);
          if (element) {
            output = Object.assign({}, element); // Create element copy to not alter element structure
            output.name =  `${this._channels[i].name}/${element.name}`; // Assign full event name
            output.id =  `${_utils_Enums_js__WEBPACK_IMPORTED_MODULE_0__["default"].Components[this._channels[i].channel[j].name]}${element.id}`; // Prefix  element ID with channel number
          } else {
            console.log('Unmapped key', args);
          }
          // Break whatever the result as matching channel is either found or not.
          break;
        }
      }
    }
    // Send output (either null or matching element)
    return output;
  }


  _findMatchingElementInChannel(args, channel) {
    let output = null;
    // Parse channel elements to match pitch and type
    for (let i = 0; i < channel.elements.length; ++i) {
      // Several pitch value can map a same element, we iterate through them
      for (let j = 0; j < channel.elements[i].note.length; ++j) {
        // In case we matched both pitch and type, we got the element
        if (args.note === channel.elements[i].note[j] && args.type === channel.elements[i].type) {
          output = channel.elements[i];
          // Break since mapping are unique
          break;
        }
      }
    }

    return output;
  }


  _buildMIDIEvent(element) {
    // Handle MIDI buttons (pushed or released)
    element.value = '';
    const type = element.elementType;
    const args = element.args;
    if (type === _utils_Enums_js__WEBPACK_IMPORTED_MODULE_0__["default"].ElementType.BUTTON) {
      if (args.velocity === 0x7F) {
        element.value = 'push';
      } else if (args.velocity === 0x00) {
        element.value = 'release';
      }
    } else if (type === _utils_Enums_js__WEBPACK_IMPORTED_MODULE_0__["default"].ElementType.JOGWHEEL) {
      if (args.velocity === 0x41) {
        element.value = 'increase';
      } else if (args.velocity === 0x3F) {
        element.value = 'decrease';
      }
    } else if (type === _utils_Enums_js__WEBPACK_IMPORTED_MODULE_0__["default"].ElementType.ROTARY) {
      if (args.velocity === 0x01) {
        element.value = 'increase';
      } else if (args.velocity === 0x7F) {
        element.value = 'decrease';
      }
    } else if (type === _utils_Enums_js__WEBPACK_IMPORTED_MODULE_0__["default"].ElementType.SELECT) {
      if (args.velocity === 0x7F) {
        element.value = 'select';
      } else if (args.velocity === 0x00) {
        element = null; // We return null to notify that no event is to fire
      }
    } else if (type === _utils_Enums_js__WEBPACK_IMPORTED_MODULE_0__["default"].ElementType.KNOB_LOW) {
      this._knobLow = element; // Store low value then return null
      this._knobLow.args = args; // Saved args straight into knob low element
      element = null; // We return null to notify that no event is to fire
    } else if (type === _utils_Enums_js__WEBPACK_IMPORTED_MODULE_0__["default"].ElementType.KNOB_HIGH) {
      const totalValue = (this._knobLow.args.velocity * 0x7F) + args.velocity;
      const percentage = totalValue / ((0x7F * 0x7F) + 0x7F);
      element.value = percentage; // Update value in percentage for element
      this._knobLow = null; // Reset know low for next knob event
    }
    // Return element with value
    return element;
  }


  _readJSONFile(path) {
    return new Promise((resolve, reject) => {
      try {
        const request = new XMLHttpRequest();
        request.overrideMimeType('application/json');
        request.open('GET', path, true);
        request.onreadystatechange = () => {
          if (request.readyState === 4) {
            if (request.status === 200) {
              resolve(JSON.parse(request.responseText));
            } else {
              reject(`Error when loading ${path}`);
            }
          }
        };
        request.send();
      } catch(err) {
        reject(`Error when loading ${path}`);
      }
    });
  }


  _cuePhones(options) {
    this.sendMIDIMessage(options.raw);
  }


  requestMIDIAccessFailure(e) {
    console.log('requestMIDIAccessFailure', e);
  }


  midiOnStateChange(event) {
    console.log('midiOnStateChange', event, event.port.name + ' ' + event.port.state);
  }


}


/* harmony default export */ __webpack_exports__["default"] = (DeviceHandler);


/***/ }),

/***/ "./src/js/core/PlaybackController.js":
/*!*******************************************!*\
  !*** ./src/js/core/PlaybackController.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _playback_Master_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../playback/Master.js */ "./src/js/playback/Master.js");
/* harmony import */ var _playback_Player_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../playback/Player.js */ "./src/js/playback/Player.js");




class PlaybackController {


  constructor() {
    this._master = null;
    this._leftPlayer = null;
    this._rightPlayer = null;

    this._init();
  }


  _init() {
    // Virtual Table output
    this._master = new _playback_Master_js__WEBPACK_IMPORTED_MODULE_0__["default"]();
    // Separated players for each deck
    this._leftPlayer = new _playback_Player_js__WEBPACK_IMPORTED_MODULE_1__["default"]({
      name: 'left',
      ac: this._master.audioContext,
      output: this._master.getMasterInput('left')
    });
    this._rightPlayer = new _playback_Player_js__WEBPACK_IMPORTED_MODULE_1__["default"]({
      name: 'right',
      ac: this._master.audioContext,
      output: this._master.getMasterInput('right')
    });
    // For headphones routing
    this._master.attachPlayer('left', this._leftPlayer);
    this._master.attachPlayer('right', this._rightPlayer);
  }


  addTrack(deckSide, track) {
    if (deckSide === 'left' || deckSide === 'right') {
      return this[`_${deckSide}Player`].loadTrack(track);
    } else {

    }
  }


  togglePlayback(deckSide, options) {
    if (deckSide === 'left' || deckSide === 'right') {
      return this[`_${deckSide}Player`].togglePlayback(options);
    } else {

    }
  }

  setVolume(deckSide, value) {
    if (deckSide === 'left' || deckSide === 'right') {
      this[`_${deckSide}Player`].setVolume(value);
    } else {

    }
  }


  setTrimVolume(deckSide, value) {
    if (deckSide === 'left' || deckSide === 'right') {
      this[`_${deckSide}Player`].setTrimVolume(value);
    } else {

    }
  }


  setProgress(deckSide, value) {
    if (deckSide === 'left' || deckSide === 'right') {
      this[`_${deckSide}Player`].setProgress(value);
    } else {

    }
  }


  adjustProgressSlow(deckSide, value) {
    if (deckSide === 'left' || deckSide === 'right') {
      this[`_${deckSide}Player`].adjustProgressSlow(value);
    } else {

    }
  }


  adjustProgressFast(deckSide, value) {
    if (deckSide === 'left' || deckSide === 'right') {
      this[`_${deckSide}Player`].adjustProgressFast(value);
    } else {

    }
  }


  setTempo(deckSide, value) {
    if (deckSide === 'left' || deckSide === 'right') {
      this[`_${deckSide}Player`].setTempo(value);
    } else {

    }
  }


  setHighEQ(deckSide, value) {
    if (deckSide === 'left' || deckSide === 'right') {
      this[`_${deckSide}Player`].setHighEQ(value);
    } else {

    }
  }


  setMidEQ(deckSide, value) {
    if (deckSide === 'left' || deckSide === 'right') {
      this[`_${deckSide}Player`].setMidEQ(value);
    } else {

    }
  }


  setLowEQ(deckSide, value) {
    if (deckSide === 'left' || deckSide === 'right') {
      this[`_${deckSide}Player`].setLowEQ(value);
    } else {

    }
  }


  setFilter(deckSide, value) {
    if (deckSide === 'left' || deckSide === 'right') {
      return this[`_${deckSide}Player`].setFilter(value);
    } else {

    }
  }


  setCuePhone(deckSide, value) {
    if (deckSide === 'left' || deckSide === 'right') {
      this._master.togglePhoneCue(deckSide, value);
    } else {

    }
  }


  crossFade(value) {
    this._master.crossFade(value);
  }


  setPad(deckSide, value, padNumber, shift) {
    if (deckSide === 'left' || deckSide === 'right') {
      this[`_${deckSide}Player`].setPad(deckSide, value, padNumber, shift);
    }
  }


  setPadType(deckSide, value, padNumber) {
    return new Promise(resolve => {
      if (deckSide === 'left' || deckSide === 'right') {
        this[`_${deckSide}Player`].setPadType(deckSide, value, padNumber);
      }

      resolve();
    });
  }


  getPlayer(deckSide) {
    return this[`_${deckSide}Player`].player;
  }


  getPlayerOutputNode(deckSide) {
    return this[`_${deckSide}Player`].sourceNode;
  }


  get audioContext() {
    return this._master.audioContext;
  }


}


/* harmony default export */ __webpack_exports__["default"] = (PlaybackController);


/***/ }),

/***/ "./src/js/core/UserInterface.js":
/*!**************************************!*\
  !*** ./src/js/core/UserInterface.js ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _ui_Timeline_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../ui/Timeline.js */ "./src/js/ui/Timeline.js");
/* harmony import */ var _ui_Deck_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ui/Deck.js */ "./src/js/ui/Deck.js");
/* harmony import */ var _ui_Mixer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../ui/Mixer.js */ "./src/js/ui/Mixer.js");
/* harmony import */ var _ui_Playlist_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../ui/Playlist.js */ "./src/js/ui/Playlist.js");
/* harmony import */ var _ui_component_ProgressRing_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../ui/component/ProgressRing.js */ "./src/js/ui/component/ProgressRing.js");







class UserInterface {


  constructor() {
    // Define custom HTML element for knob radial gauge
    window.customElements.define('progress-ring', _ui_component_ProgressRing_js__WEBPACK_IMPORTED_MODULE_4__["default"]);

    this._leftDeck = new _ui_Deck_js__WEBPACK_IMPORTED_MODULE_1__["default"]('left');
    this._rightDeck = new _ui_Deck_js__WEBPACK_IMPORTED_MODULE_1__["default"]('right');
    this._mixer = new _ui_Mixer_js__WEBPACK_IMPORTED_MODULE_2__["default"]();
    this._playlist = new _ui_Playlist_js__WEBPACK_IMPORTED_MODULE_3__["default"]();

    this._setEventSubscriptions();
  }


  _setEventSubscriptions() {
    CustomEvents.subscribe(`Player/SetVolume`, this._setVolume.bind(this));
    CustomEvents.subscribe(`Player/SetTempo`, this._setTempo.bind(this));
    CustomEvents.subscribe(`Player/Play`, this._setPlay.bind(this));
    CustomEvents.subscribe(`Player/Pause`, this._setPause.bind(this));
    CustomEvents.subscribe(`Player/Progress`, this._updateProgress.bind(this));
    CustomEvents.subscribe(`Player/EQ`, this._updateKnobs.bind(this));
    CustomEvents.subscribe(`Player/CuePhones`, this._cuePhones.bind(this));

    CustomEvents.subscribe(`Pad/Set`, this._setPad.bind(this));
    CustomEvents.subscribe(`Pad/ShiftSet`, this._setPad.bind(this));
    CustomEvents.subscribe(`Pad/Fire`, this._firePad.bind(this));
    CustomEvents.subscribe(`Pad/ClearSelection`, this._clearPadSelection.bind(this));
    CustomEvents.subscribe(`Pad/SaveHotCue`, this._saveHotCue.bind(this));
    CustomEvents.subscribe(`Pad/RemoveHotCue`, this._removeHotCue.bind(this));
    CustomEvents.subscribe(`Pad/Type`, this._setPadType.bind(this));
  }


  addTrack(deckSide, track) {
    if (deckSide === 'left' || deckSide === 'right') {
      this[`_${deckSide}Deck`].loadTrack(track);
    }
  }


  setFilter(deckSide, options) {
    if (deckSide === 'left' || deckSide === 'right') {
      this[`_${deckSide}Deck`].setFilter(options);
    }
  }


  _setPlay(options) {
    if (options.name === 'left' || options.name === 'right') {
      this[`_${options.name}Deck`].setPlay();
    }
  }


  _setPause(options) {
    if (options.name === 'left' || options.name === 'right') {
      this[`_${options.name}Deck`].setPause();
    }
  }


  _setVolume(options) {
    if (options.name === 'left' || options.name === 'right') {
      // Update left or right deck with loaded track info (stored in options.value)
      this[`_${options.name}Deck`].setVolume(options.value); // TODO Put in Mixer.js ui component ?
    }
  }


  _setTempo(options) {
    if (options.name === 'left' || options.name === 'right') {
      this[`_${options.name}Deck`].setTempo(options.value);
    }
  }


  _updateProgress(options) {
    if (options.name === 'left' || options.name === 'right') {
      this[`_${options.name}Deck`].updateProgress(options.value);
    } else {

    }
  }


  _updateKnobs(options) {
    if (options.name === 'left' || options.name === 'right') {
      this._mixer.updateKnob(options);
    }
  }


  _cuePhones(options) {
    if (options.name === 'left' || options.name === 'right') {
      this[`_${options.name}Deck`].updateCuePhone(options);
    }
  }


  _setPad(options) {
    if (options.name === 'left' || options.name === 'right') {
      this[`_${options.name}Deck`].setPad(options);
    }
  }


  _firePad(options) {
    if (options.name === 'left' || options.name === 'right') {
      this[`_${options.name}Deck`].setPad(options);
    }
  }


  _clearPadSelection(options) {
    if (options.name === 'left' || options.name === 'right') {
      this[`_${options.name}Deck`].clearPadSelection(options);
    }
  }


  _saveHotCue(options) {
    if (options.name === 'left' || options.name === 'right') {
      this[`_${options.name}Deck`].saveHotCue(options);
    }
  }


  _removeHotCue(options) {
    if (options.name === 'left' || options.name === 'right') {
      this[`_${options.name}Deck`].removeHotCue(options);
    }
  }


  _setPadType(options) {
    if (options.name === 'left' || options.name === 'right') {
      this[`_${options.name}Deck`].setPadType(options);
    }
  }


  navigateInPlaylist(deckSide, value) {
    if (deckSide === 'left' || deckSide === 'right') {
      this._playlist.navigateInPlaylist(value);
    }
  }


  getSelectedTrack() {
    return this._playlist.selectedTrack;
  }


}


/* harmony default export */ __webpack_exports__["default"] = (UserInterface);


/***/ }),

/***/ "./src/js/playback/Master.js":
/*!***********************************!*\
  !*** ./src/js/playback/Master.js ***!
  \***********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
class Master {


  constructor() {
    // Audio context app wide ; Master provide a getter to get app AudioCtx
    this._audioCtx = null;
    // Audio nodes
    this._nodes = {
      leftGain: null,
      rightGain: null,
      outputGain: null,
    };
    // L/R players to feed master with
    this._players = {};
    // Headphones L/R audio nodes
    this._leftPhoneCue = null;
    this._rightPhoneCue = null;
    // Default neutral gain value
    this._gainValue = 1;
    // Internal flag to save headphone cue state for each deck
    this._leftCue = false;
    this._rightCue = false;

    this._setuptNodes()
  }


  _setuptNodes() {
    // Create ManaMeax audio context
    this._audioCtx = new AudioContext();
    // Crossfader left entry
    this._nodes.leftGain = this._audioCtx.createGain();
    this._nodes.leftGain.gain.value = this._gainValue;
    // Crossfader right entry
    this._nodes.rightGain = this._audioCtx.createGain();
    this._nodes.rightGain.gain.value = this._gainValue;
    // Master output gain
    this._nodes.outputGain = this._audioCtx.createGain();
    this._nodes.outputGain.gain.value = this._gainValue;
    // Node connections to audioCtx output (speaker)
    this._nodes.leftGain.connect(this._nodes.outputGain);
    this._nodes.rightGain.connect(this._nodes.outputGain);
    // Get channel count and create merger accordingly to properly route 0/1 to speaker and 2/3 to headphones
    const maxChannelCount = this._audioCtx.destination.maxChannelCount;
    this._nodes.merger = this._audioCtx.createChannelMerger(maxChannelCount);
    /* Std DJ controller will contain 4 channels, otherwise... hf implementing this */
    this._audioCtx.destination.channelCount = maxChannelCount;
    // Connect L/R outputs to merger 0/1 (Main speaker). L/R for headphones (2/3) are to be set in phone cue methods
    this._nodes.leftGain.connect(this._nodes.merger, 0, 0);
    this._nodes.rightGain.connect(this._nodes.merger, 0, 1);
    // Add master gain before sending to destination
    this._nodes.merger.connect(this._nodes.outputGain);
    this._nodes.outputGain.connect(this._audioCtx.destination);
  }


  crossFade(value) {
    if (value < 0.5) { // Crossfade to left
      this._nodes.leftGain.gain.value = 1;
      this._nodes.rightGain.gain.value = value * 2;
    } else if (value > 0.5) { // Crossfade to right
      this._nodes.leftGain.gain.value = 1 - (value - 0.5) * 2;
      this._nodes.rightGain.gain.value = 1;
    } else if (value === 0.5) {
      this._nodes.leftGain.gain.value = 0.5;
      this._nodes.rightGain.gain.value = 0.5;
    }
  }


  togglePhoneCue(side, value) {
    if (side === 'left') {
      if (this._leftCue === false) {
        this._leftCue = true;
        value.raw[2] = 127; // Update MIDI event velocity to match status
      } else {
        this._leftCue = false;
        value.raw[2] = 0;
      }
    } else if (side === 'right') {
      if (this._rightCue === false) {
        this._rightCue = true;
        value.raw[2] = 127;
      } else {
        this._rightCue = false;
        value.raw[2] = 0;
      }
    }
    // Publish CuePhones with side
    value.name = side;
    CustomEvents.publish(`Player/CuePhones`, value);
    // Audio nodes routing to provide proper headphones output (channel 3/4)
    if (this._leftCue === true && this._rightCue === true) { // Both deck are listened
      // Disconnect any previous routing to headphones
      if (this._leftPhoneCue && this._rightPhoneCue) {
        this._leftPhoneCue.disconnect(this._nodes.merger, 0, 2);
        this._rightPhoneCue.disconnect(this._nodes.merger, 0, 3);
      }
      // Update heaphones audio nodes
      this._leftPhoneCue = this._players['left'].output;
      this._rightPhoneCue = this._players['right'].output;
      // Connect to merger on headphone channels
      this._leftPhoneCue.connect(this._nodes.merger, 0, 2);
      this._rightPhoneCue.connect(this._nodes.merger, 0, 3);
    } else if (this._leftCue === true || this._rightCue === true) { // Only one channel is listened
      // Disconnect any previous routing to headphones
      if (this._leftPhoneCue && this._rightPhoneCue) {
        this._leftPhoneCue.disconnect(this._nodes.merger, 0, 2);
        this._rightPhoneCue.disconnect(this._nodes.merger, 0, 3);
      }
      // Update side value if left side, right otherwise
      if (this._leftCue === true) {
        side = 'left';
      }
      // Update heaphones audio nodes
      this._leftPhoneCue = this._players[side].output;
      this._rightPhoneCue = this._players[side].output;
      // Connect to merger on headphone channels
      this._leftPhoneCue.connect(this._nodes.merger, 0, 2);
      this._rightPhoneCue.connect(this._nodes.merger, 0, 3);
    } else { // No channel deck to headphones
      // Disconnect any previous routing to headphones
      if (this._leftPhoneCue && this._rightPhoneCue) {
        this._leftPhoneCue.disconnect(this._nodes.merger, 0, 2);
        this._rightPhoneCue.disconnect(this._nodes.merger, 0, 3);
      }
      // Clear audio nodes
      this._leftPhoneCue = null;
      this._rightPhoneCue = null;
    }
  }


  attachPlayer(side, player) {
    this._players[side] = player;
  }


  getMasterInput(side) {
    return this._nodes[`${side}Gain`];
  }


  get audioContext() {
    return this._audioCtx;
  }


}


/* harmony default export */ __webpack_exports__["default"] = (Master);


/***/ }),

/***/ "./src/js/playback/Pad.js":
/*!********************************!*\
  !*** ./src/js/playback/Pad.js ***!
  \********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
class Pad {


  constructor(options) {
    this._name = options.name;
    this._player = options.player;

    this._activeMode = 0; // HotCue by default

    this._hotCues = [-1, -1, -1, -1, -1, -1, -1, -1]; // 8 items as for DDJ-400
  }


  togglePad(deckSide, value, index, shift) {
    // Fire event to refresh UI (border mostly)
    CustomEvents.publish('Pad/Set', {
      name: deckSide,
      pad: index + 1,
      shift: false,
      active: value.raw[2] === 127 ? true : false
    });

    if (value.value === 'push') { // Only do model actions on push action
      if (this._activeMode === 0) {
         /* HotCue */
        if (this._hotCues[index] === -1) {
          this._hotCues[index] = this._player.currentTime;
          CustomEvents.publish('Pad/SaveHotCue', {
            name: deckSide,
            pad: index + 1,
            active: value.raw[2] === 127 ? true : false,
            time: this._player.currentTime
          });
        } else {
          this._player.currentTime = this._hotCues[index];
        }
      }
    }
  }


  shiftTogglePad(deckSide, value, index) {
    CustomEvents.publish('Pad/ShiftSet', {
      name: deckSide,
      pad: index + 1,
      shift: true,
      active: value.raw[2] === 127 ? true : false
    });

    if (value.value === 'push') { // Only do model actions on push action
      if (this._activeMode === 0) { // HotCue
        if (this._hotCues[index] !== -1) {
          CustomEvents.publish('Pad/RemoveHotCue', {
            name: deckSide,
            pad: index + 1,
            active: value.raw[2] === 127 ? true : false
          });

          if (this._hotCues[index] !== -1) {
            this._hotCues[index] = -1;
          }
        }
      }
    }
  }


  setPadType(deckSide, value, padNumber) {
    if (this._activeMode === 0 && this._activeMode !== padNumber) {
      this._hotCues = [-1, -1, -1, -1, -1, -1, -1, -1];
      CustomEvents.publish('Pad/ClearSelection', {
        name: deckSide,
        pad: padNumber + 1,
        active: value.raw[2] === 127 ? true : false
      });
    }

    this._type = Enums.PerformanceType[padNumber + 1];
    this._activeMode = padNumber + 1;

    CustomEvents.publish('Pad/Type', {
      name: deckSide,
      pad: padNumber + 1,
      value: value.raw[2] === 127 ? true : false
    });
  }


}


/* harmony default export */ __webpack_exports__["default"] = (Pad);


/***/ }),

/***/ "./src/js/playback/Player.js":
/*!***********************************!*\
  !*** ./src/js/playback/Player.js ***!
  \***********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Pad_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Pad.js */ "./src/js/playback/Pad.js");



class Player {


  constructor(options) {
    this._name = options.name;
    this._audioCtx = options.ac;
    this._outputNode = options.output;

    this._nodes = {
      source: null,
      low: null,
      mid: null,
      high: null,
      filterLow: null,
      filterHigh: null,
      gain: null,
      trimGain: null
    };

    this._endEvtId = -1;
    this._progressRafId = -1;
    this._isPlaying = false;
    this._gainValue = 1;

    this._lowFiltered = false;
    this._highFiltered = false;

    this._pad = null;

    this._setupNodes();
    this._buildPerformancePads();
  }


  loadTrack(track) {
    return new Promise(resolve => {
      // Checking if any previous source node is playing. If true, we clean it
      if (this._isPlaying) {
        this.stopPlayback();
        CustomEvents.removeEvent(this._endEvtId);
        this._isPlaying = true; // Must restore flag to automatically start playback if load occured on playing track
      }

      this._player.src = track.url;

      const loadedListener = () => {
        this._player.removeEventListener('loadedmetadata', loadedListener); // Remove loaded track listener
        // Restore context playing state in case it turned suspended
        this._audioCtx.resume();
        // In case load occured during playback, we startPlayback
        if (this._isPlaying === true) {
          this.resumePlayback();
        }
        // Register ended event on track to reset player to time 0 when it occurs
        this._endEvtId = CustomEvents.addEvent('ended', this._player, this._trackEnded, this);
        track.duration = this._player.duration;
        resolve(track);
      };

      this._player.addEventListener('loadedmetadata', loadedListener);
    })
  }


  _setupNodes() {
    this._player = document.createElement('AUDIO');

    this._nodes.source = this._audioCtx.createMediaElementSource(this._player);

    this._nodes.gain = this._audioCtx.createGain();
    this._nodes.gain.gain.value = this._gainValue;

    this._nodes.trimGain = this._audioCtx.createGain();
    this._nodes.trimGain.gain.value = 1;

    this._nodes.low = this._audioCtx.createBiquadFilter();
  	this._nodes.low.type = "lowshelf";
  	this._nodes.low.frequency.value = 320.0;
  	this._nodes.low.gain.value = 0.0;

  	this._nodes.mid = this._audioCtx.createBiquadFilter();
  	this._nodes.mid.type = "peaking";
  	this._nodes.mid.frequency.value = 1000.0;
  	this._nodes.mid.Q.value = 0.5;
  	this._nodes.mid.gain.value = 0.0;

  	this._nodes.high = this._audioCtx.createBiquadFilter();
  	this._nodes.high.type = "highshelf";
  	this._nodes.high.frequency.value = 3200.0;
  	this._nodes.high.gain.value = 0.0;

    this._nodes.filterLow = this._audioCtx.createBiquadFilter();
    this._nodes.filterLow.type = "lowpass";
    this._nodes.filterLow.Q.value = 0;

    this._nodes.filterHigh = this._audioCtx.createBiquadFilter();
    this._nodes.filterHigh.type = "highpass";
    this._nodes.filterHigh.Q.value = 0;

    this._connectNodes();
  }


  _connectNodes(lowFilter = false) {
    this._nodes.source.connect(this._nodes.low);
    this._nodes.low.connect(this._nodes.mid);
    this._nodes.mid.connect(this._nodes.high);
    this._nodes.high.connect(this._nodes.gain);
    this._nodes.gain.connect(this._nodes.trimGain);
    this._nodes.trimGain.connect(this._outputNode);
  }


  _buildPerformancePads() {
    this._pad = new _Pad_js__WEBPACK_IMPORTED_MODULE_0__["default"]({ name: this._name, player: this.player });
  }


  togglePlayback() {
    // Play/Pause toggle using API promises
    if (this._isPlaying === true) {
      this.pausePlayback();
      return 0;
    } else {
      this.resumePlayback();
      return 127;
    }
  }


  startPlayback() {
    if (this._player && this._player.src) {
      this._isPlaying = true;
      this.resumePlayback();
    }
  }


  resumePlayback() {
    if (this._player && this._player.src) {
      this._isPlaying = true;
      this._player.play();
      this._startProgressClock();
      // Fire event to refresh UI
      CustomEvents.publish(`Player/Play`, {
        name: this._name
      });
    }
  }


  pausePlayback() {
    if (this._player && this._player.src) {
      this._isPlaying = false;
      this._player.pause();
      this._stopProgressClock();
      // Fire event to refresh UI
      CustomEvents.publish(`Player/Pause`, {
        name: this._name
      });
    }
  }


  stopPlayback() {
    if (this._player && this._player.src) {
      this.pausePlayback();
      this._player.currentTime = 0;
      console.log('stopPlayback');
    }
  }


  _trackEnded() {
    // Not updating isPlayoing as we want to keep this flag in case of new track loading
    console.log('track ended');
    this.stopPlayback();
    // Fire event to refresh UI
    CustomEvents.publish(`Player/Progress`, {
      name: this._name,
      value: {
        progress: 0,
        duration: this._player.duration
      }
    });
  }


  _startProgressClock() {
    // Fire event to refresh UI
    CustomEvents.publish(`Player/Progress`, {
      name: this._name,
      value: {
        progress: this._player.currentTime,
        duration: this._player.duration
      }
    });
    this._progressRafId = requestAnimationFrame(this._startProgressClock.bind(this));
  }


  _stopProgressClock() {
    cancelAnimationFrame(this._progressRafId);
    this._progressRafId = -1;
  }


  setVolume(value) {
    // Update internal gain value
    this._gainValue = value;
    // If gain node exists, apply new gain value
    if (this._nodes.gain) {
      this._nodes.gain.gain.value = value;
    }
    // Fire event to refresh UI
    CustomEvents.publish(`Player/SetVolume`, {
      name: this._name,
      value: value
    });
  }


  setTrimVolume(value) {
    const amount = Utils.convertKnobValue(value, 100);
    this._nodes.trimGain.gain.value = 1 + amount;
    // Fire event to refresh UI
    CustomEvents.publish(`Player/TrimGain`, {
      name: this._name,
      value: value
    });
  }


  setProgress(percentage) {
    this._player.currentTime = (this._player.duration * percentage);
  }


  adjustProgressSlow(value) {
    this._adjustProgress(value, 0.1);
  }


  adjustProgressFast(value) {
    this._adjustProgress(value, 10);
  }


  _adjustProgress(value, amount) {
    if (this._player && this._player.src) {
      if (value === 'increase') {
        this._player.playbackRate += amount;
        setTimeout(() => this._player.playbackRate -= amount, 10);
      } else if (value === 'decrease') {
        if (this._player.playbackRate - amount <= 0) {
          this._player.currentTime -= (this._player.duration / this._audioCtx.sampleRate) * amount;
        } else {
          this._player.playbackRate -= amount;
          setTimeout(() => this._player.playbackRate += amount, 10);
        }
      }
    }
  }


  setTempo(value) {
    // If gain node exists, apply new gain value
    if (this._player && this._player.src) {
      const amount = Utils.convertKnobValue(value, 16);
      // Update player playback rate
      this._player.playbackRate = 1 + amount;
      // Fire event to refresh UI
      CustomEvents.publish(`Player/SetTempo`, {
        name: this._name,
        value: amount
      });
    }
  }


  /* EQ */


  setHighEQ(value) {
    this._setEQ('high', value);
  }


  setMidEQ(value) {
    this._setEQ('mid', value);
  }


  setLowEQ(value) {
    this._setEQ('low', value);
  }


  _setEQ(type, value) {
    // If gain node exists, apply new gain value
    if (this._player && this._player.src) {
      const amount = Utils.convertKnobValue(value, 26);
      // Update player playback rate
      this._nodes[type].gain.value = amount * 100;
    }
    // Fire event to refresh UI
    CustomEvents.publish(`Player/EQ`, {
      name: this._name,
      type: type,
      value: value
    });
  }


  setFilter(value) {
    return new Promise(resolve => {
      // Knob is not centered
      if (value !== 0.5) {
        // Disconnect high in chain to insert filter
        this._nodes.high.disconnect(0);
        if (value < 0.5) {
          this._lowFiltered = true;
          this._highFiltered = false;
          this._nodes.high.connect(this._nodes.filterLow);
          this._nodes.filterLow.connect(this._nodes.gain);
          const amount = Utils.convertKnobValue(value, 22050 - 320); // Keep 320Hz when lower end is reached
          this._nodes.filterLow.frequency.value = 22050 + (amount * 100); // Amount is negative
        } else if (value > 0.5) {
          this._lowFiltered = false;
          this._highFiltered = true;
          this._nodes.high.connect(this._nodes.filterHigh);
          this._nodes.filterHigh.connect(this._nodes.gain);
          const amount = Utils.convertKnobValue(value, 22050);
          this._nodes.filterLow.frequency.value = (amount * 100);
        }
      } else { // Remove filter from audio chain
        if (this._lowFiltered === true) {
          this._lowFiltered = false;
          this._nodes.filterLow.disconnect(0);
          this._nodes.high.connect(this._nodes.gain);
        } else if (this._highFiltered === true) {
          this._highFiltered = false;
          this._nodes.filterHigh.disconnect(0);
          this._nodes.high.connect(this._nodes.gain);
        }
      }
      resolve(value);
    });
  }


  setPad(deckSide, value, padNumber, shift) {
    if (shift === false) {
      this._pad.togglePad(deckSide, value, padNumber - 1);
    } else { // Remove cue when shift is one
      this._pad.shiftTogglePad(deckSide, value, padNumber - 1);
    }
  }


  setPadType(deckSide, value, padNumber) {
    this._pad.setPadType(deckSide, value, padNumber - 1);
  }


  get sourceNode() {
    return this._nodes.trimGain;
  }


  get output() {
    return this._nodes.source;
  }


  get player() {
    return this._player;
  }


  get playing() {
    return this._isPlaying;
  }


}


/* harmony default export */ __webpack_exports__["default"] = (Player);


/***/ }),

/***/ "./src/js/ui/Deck.js":
/*!***************************!*\
  !*** ./src/js/ui/Deck.js ***!
  \***************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _component_Knob_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./component/Knob.js */ "./src/js/ui/component/Knob.js");
/* harmony import */ var _Timeline_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Timeline.js */ "./src/js/ui/Timeline.js");
/* harmony import */ var _component_Pad_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./component/Pad.js */ "./src/js/ui/component/Pad.js");





class Deck {


  constructor(name) {
    this._name = name;
    this._dom = {
      title: null,
      artist: null,
      bpm: null,
      appliedBpm: null,
      key: null,
      progress: null,
      progressBar: null,
      duration: null,
      play: null,
      faderTrack: null,
      faderProgress: null,
      cuePhone: null
    };

    this._knobs = {
      gain: null,
      filter: null
    };

    this._bpm = 0;

    this._timeline = new _Timeline_js__WEBPACK_IMPORTED_MODULE_1__["default"](this._name);
    this._performancePad = new _component_Pad_js__WEBPACK_IMPORTED_MODULE_2__["default"]({
      name: this._name,
      type: 'hotcue'
    });

    this._getElements();
    this._buildWaveform();
    this._buildKnobs();
    this._addEvents();
    this._setEventSubscriptions();
  }


  _getElements() {
    this._dom.title = document.getElementById(`track-title-${this._name}`);
    this._dom.artist = document.getElementById(`track-artist-${this._name}`);
    this._dom.bpm = document.getElementById(`track-bpm-${this._name}`);
    this._dom.appliedBpm = document.getElementById(`track-applied-bpm-${this._name}`);
    this._dom.key = document.getElementById(`track-key-${this._name}`);
    this._dom.progress = document.getElementById(`track-current-time-${this._name}`);
    this._dom.progressBar = document.getElementById(`track-waveform-progress-${this._name}`);
    this._dom.duration = document.getElementById(`track-duration-${this._name}`);
    this._dom.play = document.getElementById(`play-${this._name}`);
    this._dom.faderTrack = document.getElementById(`fader-track-${this._name}`);
    this._dom.faderProgress = document.getElementById(`fader-progress-${this._name}`);
    this._dom.cuePhone = document.getElementById(`headphones-${this._name}`);
  }


  _buildWaveform() {
    const waveformProgress = new AudioVisualizer({
      type: 'waveform',
      player: Meax.pc.getPlayer(this._name),
      renderTo: document.querySelector(`#waveform-${this._name}`),
      fftSize: 1024,
      audioContext: Meax.pc.audioContext,
      inputNode: Meax.pc.getPlayerOutputNode(this._name),
      animation: 'fade',
      wave: {
        align: 'bottom',
        barWidth: 1,
        barMarginScale: 0,
      },
      colors: {
        background: '#1D1E25',
        track: '#E7E9E7',
        progress: '#56D45B'
      }
    });
  }


  _buildKnobs() {
    this._knobs.filter = new _component_Knob_js__WEBPACK_IMPORTED_MODULE_0__["default"]({
      target: document.getElementById(`eq-filter-${this._name}`),
      type: 'filter',
      side: this._name
    });

    this._knobs.gain = new _component_Knob_js__WEBPACK_IMPORTED_MODULE_0__["default"]({
      target: document.getElementById(`eq-gain-${this._name}`),
      type: 'gain',
      side: this._name
    });
  }


  _addEvents() {
    CustomEvents.addEvent('click', this._dom.play, () => {
      Meax.pc.togglePlayback(this._name);
    }, this);

    CustomEvents.addEvent('click', this._dom.cuePhone, () => {
      Meax.pc.setCuePhone(this._name, {
        raw: [
          (this._name === 'left' ? 144 : 145),
          84,
          (this._dom.cuePhone.classList.contains('enabled') ? 127 : 0)] // See midi controller for values
      });
    }, this);

    CustomEvents.addEvent('click', this._dom.progressBar.parentNode, event => {
      const percentage = (event.offsetX / this._dom.progressBar.parentNode.offsetWidth);
      Meax.pc.setProgress(this._name, percentage);
    }, this);
  }


  _setEventSubscriptions() {
    //CustomEvents.subscribe(`Player/Filter`, this._updateFilter.bind(this));
    CustomEvents.subscribe(`Player/TrimGain`, this._updateTrimGain.bind(this));
  }


  setFilter(options) {
    this._knobs.filter.setValue(options);
  }


  _updateTrimGain(options) {
    if (this._name === options.name) {
      this._knobs.gain.setValue(options.value);
    }
  }


  setVolume(value) { // Value is a percentage [0,1]
    const topOffset = this._dom.faderTrack.offsetHeight - (value * (this._dom.faderTrack.offsetHeight));
    this._dom.faderProgress.style.top = `${topOffset}px`;
  }


  setTempo(amount) {
    this._dom.appliedBpm.innerHTML = this._bpm + (this._bpm * amount)
  }


  setPlay() {
    this._dom.play.src = './assets/img/player/pause.svg';
    this._dom.play.classList.add('playing');
  }


  setPause() {
    this._dom.play.src = './assets/img/player/play.svg';
    this._dom.play.classList.remove('playing');
  }


  loadTrack(track) {
    this._dom.title.innerHTML = track.title;
    this._dom.artist.innerHTML = track.artist;
    this._dom.bpm.innerHTML = track.bpm;
    this._dom.key.innerHTML = track.key;
    this._dom.progress.innerHTML = Utils.secondsToTimecode(0, true);
    this._dom.duration.innerHTML = Utils.secondsToTimecode(track.duration, true);
    this._dom.appliedBpm.innerHTML = track.bpm;

    this._bpm = parseInt(track.bpm);
  }


  updateProgress(options) {
    this._dom.progress.innerHTML = Utils.secondsToTimecode(options.progress, true);
    this._dom.progressBar.style.width = `${(options.progress / options.duration) * 100}%`;
  }


  updateCuePhone(options) {
    if (options.raw[2] === 127) {
      this._dom.cuePhone.classList.add('enabled');
    } else {
      this._dom.cuePhone.classList.remove('enabled');
    }
  }


  setPad(options) {
    this._performancePad.setPad(options);
  }


  clearPadSelection(options) {
    this._performancePad.clearPadSelection();
  }



  saveHotCue(options) {
    this._performancePad.saveHotCue(options);
  }


  removeHotCue(options) {
    this._performancePad.removeHotCue(options);
  }


  setPadType(options) {
    this._performancePad.setPadType(options);
  }


}


/* harmony default export */ __webpack_exports__["default"] = (Deck);


/***/ }),

/***/ "./src/js/ui/Mixer.js":
/*!****************************!*\
  !*** ./src/js/ui/Mixer.js ***!
  \****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _component_Knob_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./component/Knob.js */ "./src/js/ui/component/Knob.js");



class Mixer {


  constructor() {
    this._knobs = {};

    this._buildKnobs();
  }


  _buildKnobs() {
    const sides = ['left', 'right'];
    const types = ['high', 'mid', 'low']
    for (let i = 0; i < sides.length; ++i) {
      for (let j = 0; j < types.length; ++j) {
        this._knobs[`${types[j]}${sides[i]}EQ`] = new _component_Knob_js__WEBPACK_IMPORTED_MODULE_0__["default"]({
          target: document.getElementById(`eq-${types[j]}-${sides[i]}`),
          type: types[j],
          side: sides[i]
        });
      }
    }

    new AudioVisualizer({
      type: 'peakmeter', // Mandatory, either 'frequencybars', 'frequencycircle', 'oscilloscope', 'peakmeter' or 'spectrum'
      player: Meax.pc.getPlayer('left'), // Mandatory, the play to wire visualisation to
      audioContext: Meax.pc.audioContext,
      inputNode: Meax.pc.getPlayerOutputNode('left'),
      renderTo: document.querySelector(`#peakmeter-left`), // Mandatory, the HTML div to render component
      fftSize: 8192, // Optional (default 1024), Higher is smoother for vuemeter (doesn't consume much CPU)
      merged: true, // Optional (default false), Mix channel into single output
      orientation: 'vertical', // Optional (default horizontal), 'vertical' or 'horizontal'
      colors: { // Optional
        background: '#1D1E25', // Optional (default #1D1E25, dark grey), The canvas bg color
        min: '#56D45B', // Optional (default #56D45B, green), index 0
        step0: '#AFF2B3', // (default #AFF2B3, light green), index 0.7
        step1: '#FFAD67', // (default #FFAD67, orange), index 0.833
        step2: '#FF6B67', // (default #FF6B67, red), index 0.9
        max: '#FFBAB8' // (default #FFBAB8, light red), index 1
      }
    });

    new AudioVisualizer({
      type: 'peakmeter', // Mandatory, either 'frequencybars', 'frequencycircle', 'oscilloscope', 'peakmeter' or 'spectrum'
      player: Meax.pc.getPlayer('right'), // Mandatory, the play to wire visualisation to
      audioContext: Meax.pc.audioContext,
      inputNode: Meax.pc.getPlayerOutputNode('right'),
      renderTo: document.querySelector(`#peakmeter-right`), // Mandatory, the HTML div to render component
      fftSize: 8192, // Optional (default 1024), Higher is smoother for vuemeter (doesn't consume much CPU)
      merged: true, // Optional (default false), Mix channel into single output
      orientation: 'vertical', // Optional (default horizontal), 'vertical' or 'horizontal'
      colors: { // Optional
        background: '#1D1E25', // Optional (default #1D1E25, dark grey), The canvas bg color
        min: '#56D45B', // Optional (default #56D45B, green), index 0
        step0: '#AFF2B3', // (default #AFF2B3, light green), index 0.7
        step1: '#FFAD67', // (default #FFAD67, orange), index 0.833
        step2: '#FF6B67', // (default #FF6B67, red), index 0.9
        max: '#FFBAB8' // (default #FFBAB8, light red), index 1
      }
    });
  }


  updateKnob(options) {
    if (options.name === 'left' || options.name === 'right') {
      this._knobs[`${options.type}${options.name}EQ`].setValue(options.value);
    }
  }


}


/* harmony default export */ __webpack_exports__["default"] = (Mixer);


/***/ }),

/***/ "./src/js/ui/Playlist.js":
/*!*******************************!*\
  !*** ./src/js/ui/Playlist.js ***!
  \*******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
class Playlist {


  constructor() {
    this._dom = {
      container: null,
    };

    this._tracks = [];
    this._selected = 0; // First track always selcted on pl creation

    this._init();
  }

  _init() {
    this._dom.container = document.getElementById('playlist-container');

    const simulatedPl = [{
      url: '../assets/audio/Teminite - 01 - Elevate.mp3',
      title: 'Elevate',
      artist: 'Teminite',
      bpm: '170',
      key: 'Fm'
    }, {
      url: '../assets/audio/Teminite - 02 - Hot Fizz.mp3',
      title: 'Hot Fizz',
      artist: 'Teminite',
      bpm: '105',
      key: 'G♯m'
    }, {
      url: '../assets/audio/Teminite - 03 - Don\'t Stop.mp3',
      title: 'Don\'t Stop',
      artist: 'Teminite',
      bpm: '140',
      key: 'Fm'
    }];

    for (let i = 0; i < simulatedPl.length; ++i) {
      const track = document.createElement('DIV');
      track.classList.add('playlist-track');
      track.innerHTML = `${simulatedPl[i].artist} - ${simulatedPl[i].title}`;
      track.dataset.id = i;
      track.info = simulatedPl[i];
      this._dom.container.appendChild(track);
      this._tracks.push(track);
    }

    this._tracks[0].classList.add('selected');
    this._selected = 0;
  }


  navigateInPlaylist(value) {
    if (value === 'increase') {
      this._tracks[this._selected].classList.remove('selected');
      this._selected = (this._selected + 1) % this._tracks.length;
      this._tracks[this._selected].classList.add('selected');
    } else if (value === 'decrease') {
      this._tracks[this._selected].classList.remove('selected');
      this._selected = (this._selected - 1 + this._tracks.length) % this._tracks.length;
      this._tracks[this._selected].classList.add('selected');
    }
  }


  get selectedTrack() {
    return this._tracks[this._selected].info;
  }


}


/* harmony default export */ __webpack_exports__["default"] = (Playlist);


/***/ }),

/***/ "./src/js/ui/Timeline.js":
/*!*******************************!*\
  !*** ./src/js/ui/Timeline.js ***!
  \*******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);


class Timeline {


  constructor(name) {
    this._name = name;
    this._buildWaveform();
  }


  _buildWaveform() {
    new AudioVisualizer({
      type: 'timeline',
      player: Meax.pc.getPlayer(this._name), // Mandatory, the play to wire visualisation to
      audioContext: Meax.pc.audioContext,
      inputNode: Meax.pc.getPlayerOutputNode(this._name),
      renderTo: document.querySelector(`#timeline-${this._name}`), // Mandatory, the HTML div to render component
      fftSize: 1024, // Optional (default 1024), Higher is smoother for vuemeter (doesn't consume much CPU)
      speed: 5, // Optional (default 5), how many seconds does the canvas fit at once
      beat: {
        offset: 0.19,
        bpm: 170,
        timeSignature: 4
      },
      colors: { // Optional
        background: '#1D1E25', // Mzk background
        track: '#12B31D', // Dark green
        mainBeat: '#FF6B67', // Mzk red
        subBeat: '#56D45B' // Light grey
      }
    });
  }


}


/* harmony default export */ __webpack_exports__["default"] = (Timeline);


/***/ }),

/***/ "./src/js/ui/component/Knob.js":
/*!*************************************!*\
  !*** ./src/js/ui/component/Knob.js ***!
  \*************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
class Knob {


  constructor(options) {
    // this._centered = options.centered;
    this._container = options.target;
    this._type = options.type;
    this._side = options.side;

    this._meterContainer = document.createElement('DIV');
    this._dial = document.createElement('DIV');
    this._pin = document.createElement('DIV');
    this._label = document.createElement('P');

    this._meterContainer.classList.add('meter-container');
    this._dial.classList.add('dial');
    this._pin.classList.add('pin');
    this._dial.style.transform = 'rotate(0)';
    this._pin.style.transform = 'rotate(-45deg)';
    this._label.innerHTML = this._type.toUpperCase();

    this._meterContainer.appendChild(this._dial);
    this._meterContainer.appendChild(this._pin);
    this._container.appendChild(this._meterContainer);
    this._container.appendChild(this._label);
    /* Gauge */
    this._gauge = document.querySelector(`progress-ring.${this._type}-${this._side}`);
    this._gauge.setAttribute('progress', 0);
  }


  setValue(value) {
    if (value  > 0.5) {
      const dialAngle = 135 * ((value - 0.5) * 2); // 135 bc knob track total radius is 3Pi/4
      const gaugeAngle = ((value - 0.5) * 100) * (3 / 4);
      this._dial.style.transform = `rotate(${dialAngle}deg)`;
      this._pin.style.transform = `rotate(${dialAngle - 45}deg)`;
      this._gauge.setAttribute('progress', `${gaugeAngle}`);
    } else if (value < 0.5) {
      const dialAngle = 135 * (1 - (value * 2)); // 135 bc knob track total radius is 3Pi/4
      const gaugeAngle = ((0.5 - value) * 100) * (3 / 4);
      this._dial.style.transform = `rotate(${-dialAngle}deg)`;
      this._pin.style.transform = `rotate(${-dialAngle - 45}deg)`;
      this._gauge.setAttribute('progress', `${-gaugeAngle}`);
    } else if (value === 0.5) {
      this._dial.style.transform = 'rotate(0)';
      this._pin.style.transform = 'rotate(-45deg)';
    }
  }


}


/* harmony default export */ __webpack_exports__["default"] = (Knob);


/***/ }),

/***/ "./src/js/ui/component/Pad.js":
/*!************************************!*\
  !*** ./src/js/ui/component/Pad.js ***!
  \************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
class Pad {


  constructor(options) {
    this._name = options.name;

    this._activeType = options.type;
    this._activeTypeIndex = 0; // Default to hotcue

    this._dom = {
      ctrl1: null,
      ctrl2: null,
      ctrl3: null,
      ctrl4: null,
      pad1: null,
      pad2: null,
      pad3: null,
      pad4: null,
      pad5: null,
      pad6: null,
      pad7: null,
      pad8: null
    };

    this._getElements();
  }


  _getElements() {
    for (let i = 0; i < 4; ++i) { // Four control buttons (eight modes)
      this._dom[`ctrl${i + 1}`] = document.getElementById(`ctrl${i + 1}-${this._name}`);
    }

    for (let i = 0; i < 8; ++i) { // Eight perfo pad slots
      this._dom[`pad${i + 1}`] = document.getElementById(`pad${i + 1}-${this._name}`);
    }
  }


  setPadControl(options) {
    for (let i = 0; i < 4; ++i) {
      this._dom[`ctrl${i + 1}`].classList.remove('enabled', 'shift-enabled');
    }

    /* Check if shift is held or not (even = !shift, odd = shift) */
    if (options.pad % 2 === 0) { // Even is standard modes
      this._dom[`ctrl${(options.pad / 2) + 1}`].classList.add('enabled');
      for (let i = 0; i < 4; ++i) {
        this._dom[`ctrl${i + 1}`].firstChild.innerHTML = Enums.PerformanceType[i * 2].toUpperCase();
      }
    } else { // Odd is shifted modes
      this._dom[`ctrl${((options.pad - 1) / 2) + 1}`].classList.add('shift-enabled');
      for (let i = 0; i < 4; ++i) {
        this._dom[`ctrl${i + 1}`].firstChild.innerHTML = Enums.PerformanceType[(i * 2) + 1].toUpperCase();
      }
    }
  }


  setPad(options) {
    if (this._activeTypeIndex === 0) {
      return;
    }

    let className = 'enabled'
    if (options.shift) {
      className = 'shift-enabled';
    }

    if (options.active === true) {
      this._dom[`pad${options.pad}`].classList.add(className);
    } else {
      this._dom[`pad${options.pad}`].classList.remove('enabled', 'shift-enabled');
    }
  }


  clearPadSelection() {
    for (let i = 0; i < 8; ++i) {
      this._dom[`pad${i + 1}`].classList.remove('enabled', 'shift-enabled');
      this._dom[`pad${i + 1}`].innerHTML = '';
    }
  }


  saveHotCue(options) {
    this._dom[`pad${options.pad}`].classList.add('enabled');
    this._dom[`pad${options.pad}`].innerHTML = Utils.precisionRound(options.time, 2);
  }


  removeHotCue(options) {
    this._dom[`pad${options.pad}`].classList.remove('enabled');
    this._dom[`pad${options.pad}`].innerHTML = '';
  }


  setPadType(options) {
    this._type = Enums.PerformanceType[options.pad];
    this._activeTypeIndex = options.pad;
    this.setPadControl(options);
  }


}


/* harmony default export */ __webpack_exports__["default"] = (Pad);


/***/ }),

/***/ "./src/js/ui/component/ProgressRing.js":
/*!*********************************************!*\
  !*** ./src/js/ui/component/ProgressRing.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
class ProgressRing extends HTMLElement {


  constructor() {
    super();
    const stroke = 3;
    const radius = window.getComputedStyle(document.documentElement).getPropertyValue('--ring-radius');
    const normalizedRadius = radius - (stroke * 2) + (stroke / 2);
    this._circumference = normalizedRadius * 2 * Math.PI;

    this.setAttribute('radius', radius);

    this._root = this.attachShadow({mode: 'open'});
    this._root.innerHTML = `
      <svg height="${radius * 2}" width="${radius * 2}" >
         <circle
           stroke="#56D45B"
           stroke-dasharray="${this._circumference} ${this._circumference}"
           style="stroke-dashoffset:${this._circumference}"
           stroke-width="${stroke}"
           fill="transparent"
           r="${normalizedRadius}"
           cx="${radius}"
           cy="${radius}"
        />
      </svg>
      <style>
        circle {
          transform: rotate(-90deg);
          transform-origin: 50% 50%;
        }
      </style>
    `;
  }


  setProgress(percent) {
    const offset = this._circumference - (percent / 100 * this._circumference);
    const circle = this._root.querySelector('circle');
    circle.style.strokeDashoffset = offset;
  }


  static get observedAttributes() {
    return ['progress'];
  }


  attributeChangedCallback(name, oldValue, newValue) {
    if (name === 'progress') {
      this.setProgress(newValue);
    }
  }


}


/* harmony default export */ __webpack_exports__["default"] = (ProgressRing);


/***/ }),

/***/ "./src/js/utils/CustomEvents.js":
/*!**************************************!*\
  !*** ./src/js/utils/CustomEvents.js ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);



class CustomEvents {


  /** @summary <h1>JavaScript regular and custom events abstraction</h1>
   * @author Arthur Beaulieu
   * @since June 2020
   * @description <blockquote>The CustomEvents class provides an abstraction of JavaScript event listener, to allow
   * easy binding and removing those events. It also provides an interface to register custom events. This class is
   * meant to be used on all scopes you need ; module or global. Refer to each public method for detailed features.
   * For source code, please go to <a href="https://github.com/ArthurBeaulieu/CustomEvents.js" alt="custom-events-js">
   * https://github.com/ArthurBeaulieu/CustomEvents.js</a></blockquote>
   * @param {boolean} [debug=false] - Debug flag ; when true, logs will be output in JavaScript console at each event */
  constructor(debug = false) {
    // Prevent wrong type for debug
    if (typeof debug !== 'boolean') {
      debug = false;
    }
    /** @private
     * @member {boolean} - Internal logging flag from constructor options, allow to output each event action */
    this._debug = debug;
    /** @private
     * @member {number} - Start the ID incrementer at pseudo random value, used for both regular and custom events */
    this._idIncrementor = (Math.floor(Math.random() * Math.floor(256)) * 5678);
    /** @private
     * @member {any[]} - We store classical event listeners in array of objects containing all their information */
    this._regularEvents = [];
    /** @private
     * @member {object} - We store custom events by name as key, each key stores an Array of subscribed events */
    this._customEvents = {};
    /** @public
     * @member {string} - Component version */
    this.version = '1.2.0';
  }


  /** @method
   * @name destroy
   * @public
   * @memberof CustomEvents
   * @description <blockquote>CustomEvents destructor. Will remove all event listeners and keys in instance.</blockquote> */
  destroy() {
    // Debug logging
    this._raise('log', 'CustomEvents.destroy');
    // Remove all existing eventListener
    this.removeAllEvents();
    // Delete object attributes
    Object.keys(this).forEach(key => {
      delete this[key];
    });
  }


  /*  --------------------------------------------------------------------------------------------------------------- */
  /*  --------------------------------------  CLASSIC JS EVENTS OVERRIDE  ------------------------------------------  */
  /*                                                                                                                  */
  /*  The following methods are made to abstract the event listeners from the JavaScript layer, so you can easily     */
  /*  remove them when done using, without bothering with binding usual business for them. 'addEvent/removeEvent'     */
  /*  method replace the initial ones. 'removeAllEvents' clears all instance event listeners ; nice for destroy       */
  /*  --------------------------------------------------------------------------------------------------------------- */


  /** @method
   * @name addEvent
   * @public
   * @memberof CustomEvents
   * @description <blockquote><code>addEvent</code> method abstracts the <code>addEventListener</code> method to easily
   * remove it when needed, also to set a custom scope on callback.</blockquote>
   * @param {string} eventName - The event name to fire (mousemove, click, context etc.)
   * @param {object} element - The DOM element to attach the listener to
   * @param {function} callback - The callback function to execute when event is realised
   * @param {object} [scope=element] - The event scope to apply to the callback (optional, default to DOM element)
   * @param {object|boolean} [options=false] - The event options (useCapture and else)
   * @returns {number|boolean} - The event ID to use to manually remove an event, false if arguments are invalid */
  addEvent(eventName, element, callback, scope = element, options = false) {
    // Debug logging
    this._raise('log', `CustomEvents.addEvent: ${eventName} ${element} ${callback} ${scope} ${options}`);
    // Missing mandatory arguments
    if (eventName === null || eventName === undefined ||
      element === null || element === undefined ||
      callback === null || callback === undefined) {
      this._raise('error', 'CustomEvents.addEvent: Missing mandatory arguments');
      return false;
    }
    // Prevent wrong type for arguments (mandatory and optional)
    const err = () => {
      this._raise('error', 'CustomEvents.addEvent: Wrong type for argument');
    };
    // Test argument validity for further process
    if (typeof eventName !== 'string' || typeof element !== 'object' || typeof callback !== 'function') {
      err();
      return false;
    }
    if ((scope !== null && scope !== undefined) && typeof scope !== 'object') {
      err();
      return false;
    }
    if ((options !== null && options !== undefined) && (typeof options !== 'object' && typeof options !== 'boolean')) {
      err();
      return false;
    }
    // Save scope to callback function, default scope is DOM target object
    callback = callback.bind(scope);
    // Add event to internal array and keep all its data
    this._regularEvents.push({
      id: this._idIncrementor,
      element: element,
      eventName: eventName,
      scope: scope,
      callback: callback,
      options: options
    });
    // Add event listener with options
    element.addEventListener(eventName, callback, options);
    // Post increment to return the true event entry id, then update the incrementer
    return this._idIncrementor++;
  }


  /** @method
   * @name removeEvent
   * @public
   * @memberof CustomEvents
   * @description <blockquote><code>removeEvent</code> method abstracts the <code>removeEventListener</code> method to
   * really remove event listeners.</blockquote>
   * @param {number} eventId - The event ID to remove listener from. Returned when addEvent is called
   * @returns {boolean} - The method status ; true for success, false for non-existing event */
  removeEvent(eventId) {
    // Debug logging
    this._raise('log', `Events.removeEvent: ${eventId}`);
    // Missing mandatory arguments
    if (eventId === null || eventId === undefined) {
      this._raise('error', 'CustomEvents.removeEvent: Missing mandatory arguments');
      return false;
    }
    // Prevent wrong type for arguments (mandatory)
    if (typeof eventId !== 'number') {
      this._raise('error', 'CustomEvents.removeEvent: Wrong type for argument');
      return false;
    }
    // Returned value
    let statusCode = false; // Not found status code by default (false)
    // Iterate over saved listeners, reverse order for proper splicing
    for (let i = (this._regularEvents.length - 1); i >= 0 ; --i) {
      // If an event ID match in saved ones, we remove it and update saved listeners
      if (this._regularEvents[i].id === eventId) {
        // Update status code
        statusCode = true; // Found and removed event listener status code (true)
        this._clearRegularEvent(i);
      }
    }
    // Return with status code
    return statusCode;
  }


  /** @method
   * @name removeAllEvents
   * @public
   * @memberof CustomEvents
   * @description <blockquote>Clear all event listener registered through this class object.</blockquote>
   * @returns {boolean} - The method status ; true for success, false for not removed any event */
  removeAllEvents() {
    // Debug logging
    this._raise('log', 'CustomEvents.removeAllEvents');
    // Returned value
    let statusCode = false; // Didn't removed any status code by default (false)
    // Flag to know if there was any previously stored event listeners
    const hadEvents = (this._regularEvents.length > 0);
    // Iterate over saved listeners, reverse order for proper splicing
    for (let i = (this._regularEvents.length - 1); i >= 0; --i) {
      this._clearRegularEvent(i);
    }
    // If all events where removed, update statusCode to success
    if (this._regularEvents.length === 0 && hadEvents) {
      // Update status code
      statusCode = true; // Found and removed all events listener status code (true)
    }
    // Return with status code
    return statusCode;
  }


  /** @method
   * @name _clearRegularEvent
   * @private
   * @memberof CustomEvents
   * @description <blockquote><code>_clearRegularEvent</code> method remove the saved event listener for a
   * given index in regularEvents array range.</blockquote>
   * @param {number} index - The regular event index to remove from class attributes
   * @return {boolean} - The method status ; true for success, false for not cleared any event */
  _clearRegularEvent(index) {
    // Debug logging
    this._raise('log', `CustomEvents._clearRegularEvent: ${index}`);
    // Missing mandatory arguments
    if (index === null || index === undefined) {
      this._raise('error', 'CustomEvents._clearRegularEvent: Missing mandatory argument');
      return false;
    }
    // Prevent wrong type for arguments (mandatory)
    if (typeof index !== 'number') {
      this._raise('error', 'CustomEvents._clearRegularEvent: Wrong type for argument');
      return false;
    }
    // Check if index match an existing event in attributes
    if (this._regularEvents[index]) {
      // Remove its event listener and update regularEvents array
      const evt = this._regularEvents[index];
      evt.element.removeEventListener(evt.eventName, evt.callback, evt.options);
      this._regularEvents.splice(index, 1);
      return true;
    }

    return false;
  }


  /*  --------------------------------------------------------------------------------------------------------------- */
  /*  -------------------------------------------  CUSTOM JS EVENTS  -----------------------------------------------  */
  /*                                                                                                                  */
  /*  The three following methods (subscribe, unsubscribe, publish) are designed to reference an event by its name    */
  /*  and handle as many subscriptions as you want. When subscribing, you get an ID you can use to unsubscribe your   */
  /*  event later. Just publish with the event name to callback all its registered subscriptions.                     */
  /*  --------------------------------------------------------------------------------------------------------------- */


  /** @method
   * @name subscribe
   * @public
   * @memberof CustomEvents
   * @description <blockquote>Subscribe method allow you to listen to an event and react when it occurs.</blockquote>
   * @param {string} eventName - Event name (the one to use to publish)
   * @param {function} callback - The callback to execute when event is published
   * @param {boolean} [oneShot=false] - One shot : to remove subscription the first time callback is fired
   * @returns {number|boolean} - The event id, to be used when manually unsubscribing */
  subscribe(eventName, callback, oneShot = false) {
    // Debug logging
    this._raise('log', `CustomEvents.subscribe: ${eventName} ${callback} ${oneShot}`);
    // Missing mandatory arguments
    if (eventName === null || eventName === undefined ||
      callback === null || callback === undefined) {
      this._raise('error', 'CustomEvents.subscribe', 'Missing mandatory arguments');
      return false;
    }
    // Prevent wrong type for arguments (mandatory and optional)
    const err = () => {
      this._raise('error', 'CustomEvents.subscribe: Wrong type for argument');
    };
    if (typeof eventName !== 'string' || typeof callback !== 'function') {
      err();
      return false;
    }
    if ((oneShot !== null && oneShot !== undefined) && typeof oneShot !== 'boolean') {
      err();
      return false;
    }
    // Create event entry if not already existing in the registered events
    if (!this._customEvents[eventName]) {
      this._customEvents[eventName] = []; // Set empty array for new event subscriptions
    }
    // Push new subscription for event name
    this._customEvents[eventName].push({
      id: this._idIncrementor,
      name: eventName,
      os: oneShot,
      callback: callback
    });
    // Post increment to return the true event entry id, then update the incrementer
    return this._idIncrementor++;
  }


  /** @method
   * @name unsubscribe
   * @public
   * @memberof CustomEvents
   * @description <blockquote>Unsubscribe method allow you to revoke an event subscription from its string name.</blockquote>
   * @param {number} eventId - The subscription id returned when subscribing to an event name
   * @returns {boolean} - The method status ; true for success, false for non-existing subscription **/
  unsubscribe(eventId) {
    // Debug logging
    this._raise('log', `CustomEvents.unsubscribe: ${eventId}`);
    // Missing mandatory arguments
    if (eventId === null || eventId === undefined) {
      this._raise('error', 'CustomEvents.unsubscribe: Missing mandatory arguments');
      return false;
    }
    // Prevent wrong type for arguments (mandatory)
    if (typeof eventId !== 'number') {
      this._raise('error', 'CustomEvents.unsubscribe: Wrong type for argument');
      return false;
    }
    // Returned value
    let statusCode = false; // Not found status code by default (false)
    // Save event keys to iterate properly on this._events Object
    const keys = Object.keys(this._customEvents);
    // Reverse events iteration to properly splice without messing with iteration order
    for (let i = (keys.length - 1); i >= 0; --i) {
      // Get event subscriptions
      const subs = this._customEvents[keys[i]];
      // Iterate over events subscriptions to find the one with given id
      for (let j = 0; j < subs.length; ++j) {
        // In case we got a subscription for this events
        if (subs[j].id === eventId) {
          // Debug logging
          this._raise('log', `CustomEvents.unsubscribe: subscription found\n`, subs[j], `\nSubscription n°${eventId} for ${subs.name} has been removed`);
          // Update status code
          statusCode = true; // Found and unsubscribed status code (true)
          // Remove subscription from event Array
          subs.splice(j, 1);
          // Remove event name if no remaining subscriptions
          if (subs.length === 0) {
            delete this._customEvents[keys[i]];
          }
          // Break since id are unique and no other subscription can be found after
          break;
        }
      }
    }
    // Return with status code
    return statusCode;
  }


  /** @method
   * @name unsubscribeAllFor
   * @public
   * @memberof CustomEvents
   * @description <blockquote><code>unsubscribeAllFor</code> method clear all subscriptions registered for given event name.</blockquote>
   * @param {string} eventName - The event to clear subscription from
   * @returns {boolean} - The method status ; true for success, false for non-existing event **/
  unsubscribeAllFor(eventName) {
    // Debug logging
    this._raise('log', `CustomEvents.unsubscribeAllFor: ${eventName}`);
    // Missing mandatory arguments
    if (eventName === null || eventName === undefined) {
      this._raise('error', 'CustomEvents.unsubscribeAllFor: Missing mandatory arguments');
      return false;
    }
    // Prevent wrong type for arguments (mandatory and optional)
    if (typeof eventName !== 'string') {
      this._raise('error', 'CustomEvents.unsubscribeAllFor: Wrong type for argument');
      return false;
    }
    // Returned value
    let statusCode = false; // Not found status code by default (false)
    // Save event keys to iterate properly on this._events Object
    const keys = Object.keys(this._customEvents);
    // Iterate through custom event keys to find matching event to remove
    for (let i = 0; i < keys.length; ++i) {
      if (keys[i] === eventName) {
        // Get event subscriptions
        const subs = this._customEvents[keys[i]];
        // Iterate over events subscriptions to find the one with given id, reverse iteration to properly splice without messing with iteration order
        for (let j = (subs.length - 1); j >= 0; --j) {
          // Update status code
          statusCode = true; // Found and unsubscribed all status code (true)
          // Remove subscription from event Array
          subs.splice(j, 1);
          // Remove event name if no remaining subscriptions
          if (subs.length === 0) {
            delete this._customEvents[keys[i]];
          }
        }
      }
    }
    // Return with status code
    return statusCode;
  }


  /** @method
   * @name publish
   * @public
   * @memberof CustomEvents
   * @description <blockquote><code>Publish</code> method allow you to fire an event by name and trigger all its subscription by callbacks./blockquote>
   * @param {string} eventName - Event name (the one to use to publish)
   * @param {object} [data=undefined] - The data object to sent through the custom event
   * @returns {boolean} - The method status ; true for success, false for non-existing event **/
  publish(eventName, data = null) {
    // Debug logging
    this._raise('log', `CustomEvents.publish: ${eventName} ${data}`);
    // Missing mandatory arguments
    if (eventName === null || eventName === undefined) {
      this._raise('error', 'CustomEvents.publish: Missing mandatory arguments');
      return false;
    }
    // Prevent wrong type for arguments (mandatory and optional)
    if (typeof eventName !== 'string' || (data !== undefined && typeof data !== 'object')) {
      this._raise('error', 'CustomEvents.publish: Wrong type for argument');
      return false;
    }
    // Returned value
    let statusCode = false; // Not found status code by default (false)
    // Save event keys to iterate properly on this._events Object
    const keys = Object.keys(this._customEvents);
    // Iterate over saved custom events
    for (let i = 0; i < keys.length; ++i) {
      // If published name match an existing events, we iterate its subscriptions. First subscribed, first served
      if (keys[i] === eventName) {
        // Update status code
        statusCode = true; // Found and published status code (true)
        // Get event subscriptions
        const subs = this._customEvents[keys[i]];
        // Iterate over events subscriptions to find the one with given id
        // Reverse subscriptions iteration to properly splice without messing with iteration order
        for (let j = (subs.length - 1); j >= 0; --j) {
          // Debug logging
          this._raise('log', `CustomEvents.publish: fire callback for ${eventName}, subscription n°${subs[j].id}`, subs[j]);
          // Fire saved callback
          subs[j].callback(data);
          // Remove oneShot listener from event entry
          if (subs[j].os) {
            // Debug logging
            this._raise('log', 'CustomEvents.publish: remove subscription because one shot usage is done');
            subs.splice(j, 1);
            // Remove event name if no remaining subscriptions
            if (subs.length === 0) {
              delete this._customEvents[keys[i]];
            }
          }
        }
      }
    }
    // Return with status code
    return statusCode;
  }


  /*  --------------------------------------------------------------------------------------------------------------- */
  /*  --------------------------------------------  COMPONENT UTILS  -----------------------------------------------  */
  /*  --------------------------------------------------------------------------------------------------------------- */


  /** @method
   * @name _raise
   * @private
   * @memberof CustomEvents
   * @description <blockquote>Internal method to abstract console wrapped in debug flag./blockquote>
   * @param {string} level - The console method to call
   * @param {string} errorValue - The error value to display in console method **/
  _raise(level, errorValue) {
    if (this._debug) {
      console[level](errorValue);
    }
  }


}


/* harmony default export */ __webpack_exports__["default"] = (CustomEvents);


/***/ }),

/***/ "./src/js/utils/Enums.js":
/*!*******************************!*\
  !*** ./src/js/utils/Enums.js ***!
  \*******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);


const ElementType = Object.freeze({
    BUTTON: 'BUTTON', // BUTTONs can have 2 states ; OFF (0x00, 0), ON (0x7F, 127)
    KNOB_HIGH: 'KNOB_HIGH',
    KNOB_LOW: 'KNOB_LOW',
    JOGWHEEL: 'JOGWHEEL', // JOGWHEEL can have 2 states ; DECREASE (0x3F, 63), INCREASE (0x41, 65)
    ROTARY: 'ROTARY', // ROTARY can have 2 states ; DECREASE (0x7F, 127), INCREASE (0x01, 1)
    SELECT: 'SELECT' // BUTTONs can have 2 states ; OFF (0x00, 0), ON (0x7F, 127)
});


const Components = Object.freeze({
  DECK_LEFT: '0',
  DECK_RIGHT: '1',
  MIXER: '2',
  EFFECTS: '3',
  PAD_LEFT: '4',
  PAD_LEFT_SHIFT: '5',
  PAD_RIGHT: '6',
  PAD_RIGHT_SHIFT: '7',
});


const Commands = Object.freeze({
  PLAY: '001',
  CUE_PHONES_LEFT: '018',
  PERFORMANCE_TAB_1: '020',
  PERFORMANCE_TAB_2: '021',
  PERFORMANCE_TAB_3: '022',
  PERFORMANCE_TAB_4: '023',
  PERFORMANCE_TAB_5: '024',
  PERFORMANCE_TAB_6: '025',
  PERFORMANCE_TAB_7: '026',
  PERFORMANCE_TAB_8: '027',
  JOGWHEEL_SLOW: '028',
  JOGWHEEL_FAST: '029',
  TEMPO: '031',
  VOLUME: '033',
  VOLUME_TRIM: '035',
  HIGH_EQ: '037',
  MID_EQ: '039',
  LOW_EQ: '041',
  LEFT_LOAD_TRACK: '045',
  RIGHT_LOAD_TRACK: '047',
  SELECTION_ROTARY: '051',
  LEFT_FILTER: '059',
  RIGHT_FILTER: '061',
  CROSSFADER: '063',
  PAD_1: '078',
  PAD_2: '079',
  PAD_3: '080',
  PAD_4: '081',
  PAD_5: '082',
  PAD_6: '083',
  PAD_7: '084',
  PAD_8: '085'
});


const PerformanceType = [
  'hotcue',
  'keyboard',
  'beatloop',
  'fx1',
  'beatjump',
  'fx2',
  'sampler',
  'keyshift'
];


/* harmony default export */ __webpack_exports__["default"] = ({
  ElementType: ElementType,
  Components: Components,
  Commands: Commands,
  PerformanceType: PerformanceType
});



/*
BUTTON: {
  OFF: 0x00,
  ON: 0x7F
}
KNOB: { // High/low range are both scaled with this
  MIN: 0x00,
  MAX: 0x7F
},
JOGWHEEL: {
  INCREASE: 0x41,
  DECREASE: 0x3F
},
ROTARY: {
  INCREASE: 0x01,
  DECREASE: 0x1E
},
SELECT: {
  OFF: 0x00,
  ON: 0x7F
}*/


/***/ }),

/***/ "./src/js/utils/Utils.js":
/*!*******************************!*\
  !*** ./src/js/utils/Utils.js ***!
  \*******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
class Utils {


  constructor() {

  }


  /** @method
   * @name precisionRound
   * @public
   * @memberof Utils
   * @author Arthur Beaulieu
   * @since September 2018
   * @description Do a Math.round with a given precision (ie amount of integers after the coma)
   * @param {nunmber} value - The value to precisely round
   * @param {number} precision - The number of integers after the coma
   * @return {number} - The rounded value */
  precisionRound(value, precision) {
    const multiplier = Math.pow(10, precision || 0);
    return Math.round(value * multiplier) / multiplier;
  }


  /** @method
   * @name secondsToTimecode
   * @public
   * @memberof Utils
   * @author Arthur Beaulieu
   * @since September 2018
   * @description Convert a time in seconds into a time DD HH MM SS MS
   * @param {number} time - The time in seconds to convert
   * @return {string} - The output string according to time duration */
  secondsToTimecode(time, float) {
    const output = { h: 0, m: 0, s: 0, ms: 0 };
    // Cutting total seconds
    output.h = Math.floor(time / 3600);
    output.m = Math.floor((time - (output.h * 3600)) / 60);
    output.s = Math.floor(time - (output.h * 3600) - (output.m * 60));
    output.ms = Math.floor((time - (output.m * 60) - output.s) * 100); // If  hour value exists, we will not display ms
    // Adding an extra 0 for values inferior to 10
    if (output.h < 10) { output.h = `0${output.h}`; }
    if (output.m < 10) { output.m = `0${output.m}`; }
    if (output.s < 10) { output.s = `0${output.s}`; }
    if (output.ms < 10) { output.ms = `0${output.ms}`; }
    // Formatting output
    if (output.h > 0) {
      return `${output.h}:${output.m}:${output.s}`;
    } else {
      if (float === true) {
        return `${output.m}:${output.s}:${output.ms}`;
      } else {
        return `${output.m}:${output.s}`;
      }
    }
  }


  convertKnobValue(value, maxRange) {
    const scaledPercentage = (value * maxRange) / 100;
    const breakpoint = (maxRange / 200);
    let amount = 0;

    if (scaledPercentage < breakpoint) {
      amount = this.precisionRound(-(breakpoint - scaledPercentage) * 2, 2);
    } else if (scaledPercentage > breakpoint) {
      amount = this.precisionRound((scaledPercentage - breakpoint) * 2, 2);
    }

    return amount;
  }


}


/* harmony default export */ __webpack_exports__["default"] = (Utils);


/***/ }),

/***/ 0:
/*!**************************************************!*\
  !*** multi ./src/js/Meax.js ./src/css/meax.scss ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ./src/js/Meax.js */"./src/js/Meax.js");
module.exports = __webpack_require__(/*! ./src/css/meax.scss */"./src/css/meax.scss");


/***/ })

/******/ });